    原型模式：用原型实例指定创建对象的种类，并且通过拷贝这些原型创建新的对象。
其实就是从一个对象创建另一个可定制的对象，而且不需要知道任何创建的细节。
    在C#里面，我们可以很容易的通过Clone()方法实现原型模式。任何类，只要想支持克隆，必须实现C#中的ICloneable接口。ICloneable接口中有一Clone方法，可以在类中复写实现自定义的克隆方法。克隆的实现方法有两种：浅拷贝（shallow copy）与深拷贝（deep copy）。 浅拷贝：只负责克隆按值传递的数据（比如基本数据类型、String类型）深拷贝：除了浅拷贝要克隆的值外，还负责克隆引用类型（属性的类型也是对象）的数据。需要注意的是执行深拷贝后，原来的对象和新创建的对象不会共享任何东西；改变一个对象对另外一个对象没有任何影响。    本质：克隆生成对象    客户（Client）角色：客户端类向原型管理器提出创建对象的请求。
    抽象原型（Prototype）角色：这是一个抽象角色，通常由一个C#接口或抽象类实现。此角色给出所有的具体原型类所需的接口。在C#中，抽象原型角色通常实现了ICloneable接口。
    具体原型（Concrete Prototype）角色：被复制的对象。此角色需要实现抽象的原型角色所要求的接口。
    原型管理器（Prototype Manager）角色：创建具体原型类的对象，并记录每一个被创建的对象。
    本质：克隆生成对象。
    原型模式与工厂模式：虽然原型引入的初衷是像上面所说，但他实现起来，却完全可以达到工厂模式的效果；而且，用起来甚至比工厂模式更方便、灵活。对于工厂模式与原形模式在功能上的这点巧合，也许是因为本来工厂模式和原型模式都是创建型模式（三种类型，行为、结构），这样，他们的基本功能都能生成对象，因而使得原型模式在功能上可以代替工厂模式。工厂模式实现的生产产品的功能，关键是利用了继承的特性。也就是说，你生成的产品，一定是由同一个抽象产品类派生出来的。所以，在工厂模式下，你如果要生成一类产品，就要引入一个抽像产品类，然后再由它派生出具体产品。同样，在原型模式中，你完全可以同样定义一个这样的“抽象产品－－具体产品”层次，再利用具体产品本身的clone功能来产生具体产品本身。从而达到实现工厂模式功能的目的。实际上，在原型模式中，每个具体产品就扮演了工厂模式里的具体工厂的角色（因为每个具体产品都具有生成自己拷贝的功能，从这种意义上讲，这正是工厂的作用）。      优点：可以动态的加减产品类。简化了创建结构，耦合性降低。
    缺点：每个原型的子类都必须实现clone()操作，在包含引用类型对象时，clone会比较麻烦（递归）。
    应用场景：1.当一个系统应该独立于它的产品创建、构成和表示时。 2.当要实例化的类是在运行时刻指定时，例如，通过动态装载。3.为了避免创建一个与产品类层次平行的工厂类层次时。4.当一个类的实例只能有几个不同状态组合中的一种时。
    补充知识：MemberwiseClone()方法，如果字段是值类型的，则对该字段执行逐位复制，如果字段是引用类型，则复制引用但不复制引用的对象，因此，原始对象及其副本引用同一对象。
浅复制（按值传递）：被复制对象的所有变量都含有与原来的对象相同的值，而所有的对其他对象的引用都仍然指向原来的对象。
深复制（按地址传递）：把引用对象的变量指向复制过的新对象，而不是原有的被引用的对象。
