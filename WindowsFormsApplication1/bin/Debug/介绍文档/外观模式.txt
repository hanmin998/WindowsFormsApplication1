    外观模式：为子系统中的一组接口提供一个一致的界面，此模式定义了一个高层接口，这个接口使得这一子系统更加容易使用。
    本质：封装交互、简化调用     外观(Facade)角色：客户端可以调用这个角色的方法。此角色知晓相关的(一个或者多个)子系统的功能和责任。在正常情况下，本角色会将所有从客户端发来的请求委派到相应的子系统去。子系统(subsystem)角色：可以同时有一个或者多个子系统。每一个子系统都不是一个单独的类，而是一个类的集合。每一个子系统都可以被客户端直接调用，或者被门面角色调用。子系统并不知道门面的存在，对于子系统而言，门面仅仅是另外一个客户端而已。     【GOF】的书中指出：在外观模式中，通常只需要一个外观类，并且此外观类只有一个实例，换言之它是一个单例类。当然这并不意味着在整个系统里只能有一个外观类，而仅仅是说对每一个子系统只有一个外观类。或者说，如果一个系统有好几个子系统的话，每一个子系统有一个外观类，整个系统可以有数个外观类。 
    优点：屏蔽了外部客户端和系统内部模块的交互Facade的功能可以被多个客户端调用，可以实现复用（功能的共享）对使用Facade的人员来说，Facade大大的节省了他们的学习成本    应用场景：为一个复杂子系统提供一个简单接口时：子系统往往因为不断演化而变得越来越复杂。大多数模式使用时都会产生更多更小的类。这使得子系统更具可重用性，也更容易对子系统进行定制，但这也给那些不需要定制子系统的用户带来一些使用上的困难。 Facade可以提供一个简单的缺省视图，这一视图对大多数用户来说已经足够，而那些需要更多的可定制性的用户可以越过Facade层。当客户程序与抽象类的实现部分之间存在着很大的依赖性时，引入Facade将这个子系统与客户以及其他的子系统分离，可以提高子系统的独立性和可移植性。 在层次化结构中，可以使用Facade模式定义系统中每一层的入口点，如果子系统之间是相互依赖的，则可以让他们仅通过Facade进行通信，从而简化他们之间的依赖关系。希望包装或隐藏原有系统：Facade可以把原有系统作为自己的私有成员。原有系统与Facade类联系在一起，但使用Facade类的客户无法看到原有的系统。维护一个遗留的大型系统。跟踪对系统的使用---强迫所有客户通过Facade使用原有系统。