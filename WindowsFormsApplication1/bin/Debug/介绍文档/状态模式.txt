    定义：允许一个对象在其内部状态改变时改变它的行为，这个对象看起来似乎修改了它的类。
    本质：根据状态来分离和选择行为。状态模式是状态驱动，由上下文负责    状态模式主要解决的是当控制一个对象状态转换的条件表达式过于复杂时的情况。把状态的判断逻辑转移到表示不同状态的一系列类当中，可以把复杂的逻辑简化。
    在State模式中我们将状态逻辑和动作实现进行分离。当一个操作中要维护大量的分支语句，并且这些分支依赖于对象的状态。State模式将每一个分支都封装到独立的类中。
    优点：将与特定状态相关的行为局部化，并且将不同状态的行为分割开来消除庞大的条件分支语句，把各种状态转移逻辑分布到State的子类之间，减少了相互间的依赖。显式化进行状态转换：为不同的状态引入独立的对象，使得状态的转换变得更加明确。而且状态对象可以保证上下文不会发生内部状态不一致的状况，因为上下文中只有一个变量来记录状态对象，只要为这一个变量赋值就可以了。
    缺点：State模式问题主要是逻辑分散化，状态逻辑分布到了很多的State的子类中，很难看到整个的状态逻辑图，这也带来了代码的维护问题。    状态模式与策略模式比较：State模式和Strategy模式有很大程度上的相似：它们都有一个Context类，都是通过委托（组合）给一个具有多个派生类的多态基类实现Context的算法逻辑两者最大的差别就是State模式中派生类持有指向Context对象的引用，并通过这个引用调用Context中的方法，但在Strategy模式中就没有这种情况。
    举例：1.在线投票：同一个用户只能投一票如果一个用户反复投票，而且投票次数超过5次，判定为恶意投票，要取消该用户的投票资格，并取消他所投的票若超过8次，将进入黑名单，禁止再登录和使用系统。2.工作流中的请假流程：某人提出请假申请，先由项目经理审批，如果项目经理不同意，审批就直接结束如项目经理同意，再看是否超过3天，如果三天以内，审批直接结束否则，交给部门经理，部门经理审核后，无论是否同意，审批直接结束