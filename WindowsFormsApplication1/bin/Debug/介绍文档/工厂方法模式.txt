    工厂方法模式：是指定义一个接口用于创建对象，但是让子类决定初始化哪个类。工厂方法把一个类的实例化延迟到其子类。
工厂方法（FactoryMethod）模式是类的创建模式，其用意是定义一个创建产品对象的工厂接口，将实际创建工作推迟到子类中。在工厂方法模式中，核心的工厂类不再负责所有产品的创建，而是将具体创建工作交给子类去做。这个核心类仅仅负责给出具体工厂必须实现的接口，而不接触哪一个产品类被实例化这种细节。这使得工厂方法模式可以允许系统在不修改工厂角色的情况下引进新产品。工厂方法模式是简单工厂模式的进一步抽象和推广。由于使用了多态性，工厂方法模式保持了简单工厂模式的优点，而且部分克服了它的缺点。工厂方法类的核心是一个抽象工厂类，而简单工厂模式把核心放在一个具体类上。工厂方法模式有一个别名叫多态性工厂模式，因为具体工厂类都有共同的接口，或者有共同的抽象父类。       抽象工厂(Creator)角色：是工厂方法模式的核心，与应用程序无关。任何在模式中创建的对象的工厂类必须实现这个接口。
    具体工厂(Concrete Creator)角色：这是实现抽象工厂接口的具体工厂类，包含与应用程序密切相关的逻辑，并且受到应用程序调用以创建产品对象。在上图中有两个这样的角色：BulbCreator与TubeCreator。
    抽象产品(Product)角色：工厂方法模式所创建的对象的超类型，也就是产品对象的共同父类或共同拥有的接口。在上图中，这个角色是Light。
    具体产品(Concrete Product)角色：这个角色实现了抽象产品角色所定义的接口。某具体产品有专门的具体工厂创建，它们之间往往一一对应。
    本质：延迟到子类来选择实现。
    优点：工厂类是整个模式的关键.包含了必要的逻辑判断,根据客户端的选择条件动态实例化相关的类，对于客户端来说，去除了与具体产品的依赖。通过使用工厂类,外界可以从直接创建具体产品对象的尴尬局面摆脱出来,仅仅需要负责“消费”对象就可以了。而不必管这些对象究竟如何创建及如何组织的．明确了各自的职责和权利，有利于整个软件体系结构的优化。 
    缺点：违背了开放--封闭原则对工厂类过于依赖。在添加新产品时，需要编写新的具体产品类，而且还要 提供与之对应的具体工厂类，系统中类的个数将成对增 加，在一定程度上增加了系统的复杂度，有更多的类需 要编译和运行，会给系统带来一些额外的开销。 由于考虑到系统的可扩展性，需要引入抽象层，在客户 端代码中均使用抽象层进行定义，增加了系统的抽象性 和理解难度，且在实现时可能需要用到DOM、反射等技 术，增加了系统的实现难度。
应用场景：1.当一个类不知道它所必须创建的对象的类的时候。2.当一个类希望由它的子类来指定它所创建的对象的时候。3.将创建对象的职责委托给多个帮助类中的某一个，并且希望将哪一个帮助子类是代理者这一信息局部化的时候。