    装饰模式（Decorator）：动态的给一个对象添加一些额外的职责，就增加功能来说，装饰模式比生成子类更为灵活。
    装饰模式常常被称为包裹模式，就是因为每一个具体装饰类都将下一个具体装饰类或者具体构件类包裹起来。装饰模式包含两部分内容，即装饰对象和被装饰对象。    Component是定义一个对象接口，可以给这些对象动态的添加职责。ConcreteComponent是定义了一个具体的对象，也可以给这个对象添加一些职责。Decorator，装饰抽象类，继承了Component，从外类来扩展Component类的功能，但对于Component类来说，是无需知道Decorator的存在的。至于ConcreteDecorator就是具体的装饰对象，起到给Component添加职责的功能。装饰模式是利用SetComponent来对对象进行包装的。这样每个装饰对象的实现就和如何使用这个对象分离开来了，每个装饰对象只关心自己的功能，不需要关心如何变添加到对象链中。如果只有一个ConcreteComponent类而没有抽象的Component类，那么Decorator类可以是ConcreteComponent的一个子类。同样道理，如果只有一个ConcreteDecorator类，那么就没有必要建立一个单独的Decorator类，而可以把Decorator和ConcreteDecorator的责任合并成一个类。
    装饰模式是为已有功能动态的添加更多功能的一种方式。
    优点：装饰模式与继承关系的目的都是要扩展对象的功能，但是装饰模式可以提供比继承更多的灵活性。 通过使用不同的具体装饰类以及这些装饰类的排列组合，设计师可以创造出很多不同行为的组合。 
    缺点：会产生很多细粒度对象
    装饰模式与策略模式：策略模式改变的是对象的内核，装饰模式改变的是对象的外壳，策略模式是一层调用，装饰模式是递归调用，可以有机结合。
    装饰模式与AOP：AOP是OOP的延续，是（Aspect Oriented Programming）的缩写，意思是面向方面编程。 面向对象开发中，考虑系统的角度通常是纵向的。AOP主要的功能是：日志记录，性能统计，安全控制，事务处理，异常处理等等。主要的意图是：将日志记录，性能统计，安全控制，事务处理，异常处理等代码从业务逻辑代码中划分出来，通过对这些行为的分离，我们希望可以将它们独立到非指导业务逻辑的方法中，进而改变这些行为的时候不影响业务逻辑的代码。     应用环境：当系统需要新功能的时候，是向旧的类中添加新代码。这些新添加的代码通常装饰了原有类的核心职责或主要行为，他们在主类中加入了新的字段，新的方法，新的逻辑，从而增加了主类的复杂度，这些新加入的东西往往是为了满足某些只在特定情况下才会发生的特殊行为的需要。装饰模式提供了一个非常好的解决方案，它把每个要装饰的功能放在单独的类中，并让这个类包装它所要封装的对象，因此，当需要执行特殊行为时，客户代码就可以在运行时根据需要有选择的，按顺序的使用装饰功能封装对象。